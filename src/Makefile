#******************************************************************************
# Copyright (C) 2017 by Alex Fosdick - University of Colorado
#
# Redistribution, modification or use of this software in source or binary
# forms is permitted as long as the files maintain this copyright. Users are 
# permitted to modify this and use it to learn about the field of embedded
# software. Alex Fosdick and the University of Colorado are not liable for any
# misuse of this material. 
#
#*****************************************************************************

#------------------------------------------------------------------------------
# This is a makefile that can compile multiple source files and support two platform targets
# with thier own specific compiler and flags . 
# These two platforms are the HOST and the MSP432. 
# The host embedded system will use the native compiler, gcc. 
# The target embedded system will use the cross compiler, arm-none-eabi-gcc.
# The target platform must be provided at the command line with the make command to set the 
# platform you are compiling for.
#
# Use: make [TARGET] [PLATFORM-OVERRIDES]
#
# Build Targets:
# @HOST we use gcc compiler for the host and ansi c99 standard
# @The host embedded system (MSP432) we use arm-none-eabi-gcc compiler for it and ansi c99 std
# target cpu is cortex-m4 and it's archeticture is thumb armv7e-m float-abi=hard
# mfpu=fpv4-sp-d16 and it's specs is nosys.specs
#
# Platform Overrides:
# @The HOST machine
# @The HOST embedded system MSP432
#
#------------------------------------------------------------------------------
include sources.mk
 #linker file directory
LINKER_FILE = ../msp432p401r.lds
 #this is the target output name
TARGET=c1m2

 #if PLATFORM=MSP432
ifeq ($(PLATFORM) ,MSP432)
	 #Architectures Specific Flags
	CPU=cortex-m4
	ARCH=thumb
	ARCH_=armv7e-m
	FLOAT_ABI=hard
	FPU=fpv4-sp-d16
	SPECS=nosys.specs
	 #Compiler Flags and Defines
	CC = arm-none-eabi-gcc
	LD = arm-none-eabi-ld
	 # @LDFLAGS generate map file and use linker file
	LDFLAGS = -Wl,-Map=$(TARGET).map -T $(LINKER_FILE)
	 # @CFFLAGS add include (files.h) directory and specifie the compiler flags
	CFFLAGS = -mcpu=$(CPU) -m$(ARCH)  $(INCLUDES)               \
	           --specs=$(SPECS) -Wall -Werror -std=c99 -g -O0   \
		   -mfpu=$(FPU) -mfloat-abi=$(FLOAT_ABI) -march=$(ARCH_) 

 #rename every .c to .o file and stores it the variable OBJS
OBJS=$(MSP_SOURCES:.c=.o)

 #if PLATFORM=HOST
else
	 #Compiler Flags and Defines
	CC = gcc
	 # @LDFLAGS generates map file 
	LDFLAGS = -Wl,-Map=$(TARGET).map 
	 # @CFFLAGS add include (files.h) directory and specify the compiler flags
	CFFLAGS = -Wall -Werror -std=c99 -g -O0 $(INCLUDES)

 #rename every .c to .o file and stores it the variable OBJS
OBJS=$(HOST_SOURCES:.c=.o)

endif

 #preprocessor flags to generate .d dependency files
CPPFLAGS= -MMD -MP

 # $< dependencies , $@ target to be built
 #  %target to be built : % it's dependencies
%.i : %.c
 #rule to build and it must start with a tab
	$(CC) -E $< $(CFFLAGS) -o $@ -D$(PLATFORM)

%.asm : %.c
	$(CC) -S $< $(CFFLAGS) -o $@ -D$(PLATFORM)

%.o : %.c
	$(CC) -MMD -MP -c -o $@ $< $(CFFLAGS) -D$(PLATFORM)

 #PHONY protection to not confuse target name with an actual file 
 #so we could use the command  "make compile-all"
.PHONY: compile-all
compile-all: all

 #so we could use the command  "make build"
.PHONY: build
build: all

 #so we could use the command  "make all"
.PHONY: all
all: $(TARGET).out

$(TARGET).out:$(OBJS)
	$(CC) -o $@ $^ $(CFFLAGS) $(LDFLAGS) -D$(PLATFORM)

 #so we could use the command "make clean" to clean all that files
.PHONY: clean
clean:
	rm *.o *.map *.out *.asm *.i *.d

